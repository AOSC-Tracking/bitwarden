{"version":3,"file":"146.1a8eb7a8ae761aab308d.js","mappings":"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","sources":["webpack://@bitwarden/web-vault/./src/app/auth/migrate-encryption/migrate-legacy-encryption.service.ts","webpack://@bitwarden/web-vault/./src/app/auth/migrate-encryption/migrate-legacy-encryption.component.ts","webpack://@bitwarden/web-vault/./src/app/auth/migrate-encryption/migrate-legacy-encryption.component.html"],"sourcesContent":["import { Injectable } from \"@angular/core\";\nimport { firstValueFrom } from \"rxjs\";\n\nimport { ApiService } from \"@bitwarden/common/abstractions/api.service\";\nimport { OrganizationUserService } from \"@bitwarden/common/abstractions/organization-user/organization-user.service\";\nimport { OrganizationUserResetPasswordEnrollmentRequest } from \"@bitwarden/common/abstractions/organization-user/requests\";\nimport { OrganizationApiServiceAbstraction } from \"@bitwarden/common/admin-console/abstractions/organization/organization-api.service.abstraction\";\nimport { OrganizationService } from \"@bitwarden/common/admin-console/abstractions/organization/organization.service.abstraction\";\nimport { EmergencyAccessStatusType } from \"@bitwarden/common/auth/enums/emergency-access-status-type\";\nimport { EmergencyAccessUpdateRequest } from \"@bitwarden/common/auth/models/request/emergency-access-update.request\";\nimport { UpdateKeyRequest } from \"@bitwarden/common/models/request/update-key.request\";\nimport { CryptoService } from \"@bitwarden/common/platform/abstractions/crypto.service\";\nimport { EncryptService } from \"@bitwarden/common/platform/abstractions/encrypt.service\";\nimport { StateService } from \"@bitwarden/common/platform/abstractions/state.service\";\nimport { Utils } from \"@bitwarden/common/platform/misc/utils\";\nimport { EncryptedString, EncString } from \"@bitwarden/common/platform/models/domain/enc-string\";\nimport { UserKey } from \"@bitwarden/common/platform/models/domain/symmetric-crypto-key\";\nimport { SendWithIdRequest } from \"@bitwarden/common/tools/send/models/request/send-with-id.request\";\nimport { SendService } from \"@bitwarden/common/tools/send/services/send.service.abstraction\";\nimport { CipherService } from \"@bitwarden/common/vault/abstractions/cipher.service\";\nimport { FolderService } from \"@bitwarden/common/vault/abstractions/folder/folder.service.abstraction\";\nimport { SyncService } from \"@bitwarden/common/vault/abstractions/sync/sync.service.abstraction\";\nimport { CipherWithIdRequest } from \"@bitwarden/common/vault/models/request/cipher-with-id.request\";\nimport { FolderWithIdRequest } from \"@bitwarden/common/vault/models/request/folder-with-id.request\";\n\n// TODO: PM-3797 - This service should be expanded and used for user key rotations in change-password.component.ts\n@Injectable()\nexport class MigrateFromLegacyEncryptionService {\n  constructor(\n    private organizationService: OrganizationService,\n    private organizationApiService: OrganizationApiServiceAbstraction,\n    private organizationUserService: OrganizationUserService,\n    private apiService: ApiService,\n    private cryptoService: CryptoService,\n    private encryptService: EncryptService,\n    private syncService: SyncService,\n    private cipherService: CipherService,\n    private folderService: FolderService,\n    private sendService: SendService,\n    private stateService: StateService\n  ) {}\n\n  /**\n   * Validates the master password and creates a new user key.\n   * @returns A new user key along with the encrypted version\n   */\n  async createNewUserKey(masterPassword: string): Promise<[UserKey, EncString]> {\n    // Create master key to validate the master password\n    const masterKey = await this.cryptoService.makeMasterKey(\n      masterPassword,\n      await this.stateService.getEmail(),\n      await this.stateService.getKdfType(),\n      await this.stateService.getKdfConfig()\n    );\n\n    if (!masterKey) {\n      throw new Error(\"Invalid master password\");\n    }\n\n    if (!(await this.cryptoService.isLegacyUser(masterKey))) {\n      throw new Error(\"Invalid master password or user may not be legacy\");\n    }\n\n    // Set master key again in case it was lost (could be lost on refresh)\n    await this.cryptoService.setMasterKey(masterKey);\n    return await this.cryptoService.makeUserKey(masterKey);\n  }\n\n  /**\n   * Updates the user key, master key hash, private key, folders, ciphers, and sends\n   * on the server.\n   * @param masterPassword The master password\n   * @param newUserKey The new user key\n   * @param newEncUserKey The new encrypted user key\n   */\n  async updateKeysAndEncryptedData(\n    masterPassword: string,\n    newUserKey: UserKey,\n    newEncUserKey: EncString\n  ): Promise<void> {\n    // Create new request and add master key and hash\n    const request = new UpdateKeyRequest();\n    request.key = newEncUserKey.encryptedString;\n    request.masterPasswordHash = await this.cryptoService.hashMasterKey(\n      masterPassword,\n      await this.cryptoService.getOrDeriveMasterKey(masterPassword)\n    );\n\n    // Sync before encrypting to make sure we have latest data\n    await this.syncService.fullSync(true);\n\n    request.privateKey = await this.encryptPrivateKey(newUserKey);\n    request.folders = await this.encryptFolders(newUserKey);\n    request.ciphers = await this.encryptCiphers(newUserKey);\n    request.sends = await this.encryptSends(newUserKey);\n\n    return this.apiService.postAccountKey(request);\n  }\n\n  /**\n   * Gets user's emergency access details from server and encrypts with new user key\n   * on the server.\n   * @param newUserKey The new user key\n   */\n  async updateEmergencyAccesses(newUserKey: UserKey) {\n    const emergencyAccess = await this.apiService.getEmergencyAccessTrusted();\n    // Any Invited or Accepted requests won't have the key yet, so we don't need to update them\n    const allowedStatuses = new Set([\n      EmergencyAccessStatusType.Confirmed,\n      EmergencyAccessStatusType.RecoveryInitiated,\n      EmergencyAccessStatusType.RecoveryApproved,\n    ]);\n    const filteredAccesses = emergencyAccess.data.filter((d) => allowedStatuses.has(d.status));\n\n    for (const details of filteredAccesses) {\n      // Get public key of grantee\n      const publicKeyResponse = await this.apiService.getUserPublicKey(details.granteeId);\n      const publicKey = Utils.fromB64ToArray(publicKeyResponse.publicKey);\n\n      // Encrypt new user key with public key\n      const encryptedKey = await this.cryptoService.rsaEncrypt(newUserKey.key, publicKey);\n\n      const updateRequest = new EmergencyAccessUpdateRequest();\n      updateRequest.type = details.type;\n      updateRequest.waitTimeDays = details.waitTimeDays;\n      updateRequest.keyEncrypted = encryptedKey.encryptedString;\n\n      await this.apiService.putEmergencyAccess(details.id, updateRequest);\n    }\n  }\n\n  /** Updates all admin recovery keys on the server with the new user key\n   * @param masterPassword The user's master password\n   * @param newUserKey The new user key\n   */\n  async updateAllAdminRecoveryKeys(masterPassword: string, newUserKey: UserKey) {\n    const allOrgs = await this.organizationService.getAll();\n\n    for (const org of allOrgs) {\n      // If not already enrolled, skip\n      if (!org.resetPasswordEnrolled) {\n        continue;\n      }\n\n      // Retrieve public key\n      const response = await this.organizationApiService.getKeys(org.id);\n      const publicKey = Utils.fromB64ToArray(response?.publicKey);\n\n      // Re-enroll - encrypt user key with organization public key\n      const encryptedKey = await this.cryptoService.rsaEncrypt(newUserKey.key, publicKey);\n\n      // Create/Execute request\n      const request = new OrganizationUserResetPasswordEnrollmentRequest();\n      request.resetPasswordKey = encryptedKey.encryptedString;\n      request.masterPasswordHash = await this.cryptoService.hashMasterKey(\n        masterPassword,\n        await this.cryptoService.getOrDeriveMasterKey(masterPassword)\n      );\n\n      await this.organizationUserService.putOrganizationUserResetPasswordEnrollment(\n        org.id,\n        org.userId,\n        request\n      );\n    }\n  }\n\n  private async encryptPrivateKey(newUserKey: UserKey): Promise<EncryptedString | null> {\n    const privateKey = await this.cryptoService.getPrivateKey();\n    if (!privateKey) {\n      return;\n    }\n    return (await this.encryptService.encrypt(privateKey, newUserKey)).encryptedString;\n  }\n\n  private async encryptFolders(newUserKey: UserKey): Promise<FolderWithIdRequest[] | null> {\n    const folders = await firstValueFrom(this.folderService.folderViews$);\n    if (!folders) {\n      return;\n    }\n    return await Promise.all(\n      folders.map(async (folder) => {\n        const encryptedFolder = await this.folderService.encrypt(folder, newUserKey);\n        return new FolderWithIdRequest(encryptedFolder);\n      })\n    );\n  }\n\n  private async encryptCiphers(newUserKey: UserKey): Promise<CipherWithIdRequest[] | null> {\n    const ciphers = await this.cipherService.getAllDecrypted();\n    if (!ciphers) {\n      return;\n    }\n    return await Promise.all(\n      ciphers.map(async (cipher) => {\n        const encryptedCipher = await this.cipherService.encrypt(cipher, newUserKey);\n        return new CipherWithIdRequest(encryptedCipher);\n      })\n    );\n  }\n\n  private async encryptSends(newUserKey: UserKey): Promise<SendWithIdRequest[] | null> {\n    const sends = await firstValueFrom(this.sendService.sends$);\n    if (!sends) {\n      return;\n    }\n    return await Promise.all(\n      sends.map(async (send) => {\n        const sendKey = await this.encryptService.decryptToBytes(send.key, null);\n        send.key = (await this.encryptService.encrypt(sendKey, newUserKey)) ?? send.key;\n        return new SendWithIdRequest(send);\n      })\n    );\n  }\n}\n","import { Component } from \"@angular/core\";\nimport { FormControl, FormGroup, Validators } from \"@angular/forms\";\n\nimport { CryptoService } from \"@bitwarden/common/platform/abstractions/crypto.service\";\nimport { I18nService } from \"@bitwarden/common/platform/abstractions/i18n.service\";\nimport { LogService } from \"@bitwarden/common/platform/abstractions/log.service\";\nimport { MessagingService } from \"@bitwarden/common/platform/abstractions/messaging.service\";\nimport { PlatformUtilsService } from \"@bitwarden/common/platform/abstractions/platform-utils.service\";\n\nimport { SharedModule } from \"../../shared\";\n\nimport { MigrateFromLegacyEncryptionService } from \"./migrate-legacy-encryption.service\";\n\n// The master key was originally used to encrypt user data, before the user key was introduced.\n// This component is used to migrate from the old encryption scheme to the new one.\n@Component({\n  standalone: true,\n  imports: [SharedModule],\n  providers: [MigrateFromLegacyEncryptionService],\n  templateUrl: \"migrate-legacy-encryption.component.html\",\n})\nexport class MigrateFromLegacyEncryptionComponent {\n  protected formGroup = new FormGroup({\n    masterPassword: new FormControl(\"\", [Validators.required]),\n  });\n\n  constructor(\n    private i18nService: I18nService,\n    private platformUtilsService: PlatformUtilsService,\n    private migrationService: MigrateFromLegacyEncryptionService,\n    private cryptoService: CryptoService,\n    private messagingService: MessagingService,\n    private logService: LogService\n  ) {}\n\n  submit = async () => {\n    this.formGroup.markAsTouched();\n\n    if (this.formGroup.invalid) {\n      return;\n    }\n\n    const hasUserKey = await this.cryptoService.hasUserKey();\n    if (hasUserKey) {\n      this.messagingService.send(\"logout\");\n      throw new Error(\"User key already exists, cannot migrate legacy encryption.\");\n    }\n\n    const masterPassword = this.formGroup.value.masterPassword;\n\n    try {\n      // Create new user key\n      const [newUserKey, masterKeyEncUserKey] = await this.migrationService.createNewUserKey(\n        masterPassword\n      );\n\n      // Update admin recover keys\n      await this.migrationService.updateAllAdminRecoveryKeys(masterPassword, newUserKey);\n\n      // Update emergency access\n      await this.migrationService.updateEmergencyAccesses(newUserKey);\n\n      // Update keys, folders, ciphers, and sends\n      await this.migrationService.updateKeysAndEncryptedData(\n        masterPassword,\n        newUserKey,\n        masterKeyEncUserKey\n      );\n\n      this.platformUtilsService.showToast(\n        \"success\",\n        this.i18nService.t(\"keyUpdated\"),\n        this.i18nService.t(\"logBackInOthersToo\"),\n        { timeout: 15000 }\n      );\n      this.messagingService.send(\"logout\");\n    } catch (e) {\n      this.logService.error(e);\n      throw e;\n    }\n  };\n}\n","<form [formGroup]=\"formGroup\" [bitSubmit]=\"submit\">\n  <div class=\"tw-mt-12 tw-flex tw-justify-center\">\n    <div class=\"tw-max-w-xl\">\n      <h1 bitTypography=\"h1\" class=\"tw-mb-4 tw-text-center\">{{ \"updateEncryptionKey\" | i18n }}</h1>\n      <div\n        class=\"tw-block tw-rounded tw-border tw-border-solid tw-border-secondary-300 tw-bg-background tw-p-8\"\n      >\n        <p>\n          {{ \"updateEncryptionSchemeDesc\" | i18n }}\n          <a\n            href=\"https://bitwarden.com/help/account-encryption-key/#rotate-your-encryption-key\"\n            target=\"_blank\"\n            rel=\"noopener\"\n            >{{ \"learnMore\" | i18n }}</a\n          >\n        </p>\n        <bit-callout type=\"warning\">{{ \"updateEncryptionKeyWarning\" | i18n }}</bit-callout>\n\n        <bit-form-field>\n          <bit-label>{{ \"masterPass\" | i18n }}</bit-label>\n          <input\n            id=\"masterPassword\"\n            bitInput\n            type=\"password\"\n            formControlName=\"masterPassword\"\n            appAutofocus\n          />\n          <button type=\"button\" bitIconButton bitSuffix bitPasswordInputToggle></button>\n        </bit-form-field>\n        <button type=\"submit\" bitButton bitFormButton buttonType=\"primary\" block>\n          {{ \"updateEncryptionKey\" | i18n }}\n        </button>\n      </div>\n    </div>\n  </div>\n</form>\n"],"names":["MigrateFromLegacyEncryptionService","constructor","organizationService","organizationApiService","organizationUserService","apiService","cryptoService","encryptService","syncService","cipherService","folderService","sendService","stateService","createNewUserKey","masterPassword","masterKey","this","makeMasterKey","getEmail","getKdfType","getKdfConfig","Error","isLegacyUser","setMasterKey","makeUserKey","updateKeysAndEncryptedData","newUserKey","newEncUserKey","request","key","encryptedString","masterPasswordHash","hashMasterKey","getOrDeriveMasterKey","fullSync","privateKey","encryptPrivateKey","folders","encryptFolders","ciphers","encryptCiphers","sends","encryptSends","postAccountKey","updateEmergencyAccesses","emergencyAccess","getEmergencyAccessTrusted","allowedStatuses","Set","Confirmed","RecoveryInitiated","RecoveryApproved","filteredAccesses","data","filter","d","has","status","details","publicKeyResponse","getUserPublicKey","granteeId","publicKey","fromB64ToArray","encryptedKey","rsaEncrypt","updateRequest","type","waitTimeDays","keyEncrypted","putEmergencyAccess","id","updateAllAdminRecoveryKeys","allOrgs","getAll","org","resetPasswordEnrolled","response","getKeys","resetPasswordKey","putOrganizationUserResetPasswordEnrollment","userId","getPrivateKey","encrypt","firstValueFrom","folderViews$","Promise","all","map","folder","encryptedFolder","getAllDecrypted","cipher","encryptedCipher","sends$","send","sendKey","decryptToBytes","MigrateFromLegacyEncryptionComponent","i18nService","platformUtilsService","migrationService","messagingService","logService","formGroup","required","submit","markAsTouched","invalid","hasUserKey","value","masterKeyEncUserKey","showToast","t","timeout","e","error"],"sourceRoot":""}